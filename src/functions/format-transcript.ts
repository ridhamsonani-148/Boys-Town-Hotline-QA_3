import { 
  S3Client, 
  GetObjectCommand, 
  PutObjectCommand 
} from '@aws-sdk/client-s3';

const s3Client = new S3Client({});
const { BUCKET_NAME } = process.env;

if (!BUCKET_NAME) {
  throw new Error('Required environment variable BUCKET_NAME must be set');
}

interface TranscriptItem {
  ParticipantRole: string;
  Content: string;
  BeginOffsetMillis: number;
  EndOffsetMillis: number;
  Sentiment: string;
  Id: string;
}

interface TranscriptSummary {
  AutoGenerated: {
    OverallSummary: {
      Content: string;
    }
  }
}

interface TranscribeOutput {
  Transcript: TranscriptItem[];
  ConversationCharacteristics: {
    ContactSummary: TranscriptSummary;
  }
}

// Validation functions
function validateTranscriptItem(item: any): TranscriptItem {
  if (!item || typeof item !== 'object') {
    throw new Error('Invalid transcript item structure');
  }

  // Validate ParticipantRole
  if (!item.ParticipantRole || typeof item.ParticipantRole !== 'string') {
    throw new Error('Invalid ParticipantRole');
  }
  const validRoles = ['AGENT', 'CUSTOMER', 'SYSTEM'];
  const sanitizedRole = item.ParticipantRole.toUpperCase().slice(0, 20).replace(/[^A-Z_]/g, '');
  if (!validRoles.includes(sanitizedRole) && !sanitizedRole.startsWith('AGENT') && !sanitizedRole.startsWith('CUSTOMER')) {
    throw new Error(`Invalid ParticipantRole: ${item.ParticipantRole}`);
  }

  // Validate Content (the actual transcript text)
  if (typeof item.Content !== 'string') {
    throw new Error('Invalid Content - must be string');
  }
  // Sanitize content - remove potential script injections but keep normal punctuation
  const sanitizedContent = item.Content
    .slice(0, 10000) // Limit length to prevent DoS
    .replace(/<script[^>]*>.*?<\/script>/gi, '') // Remove script tags
    .replace(/<iframe[^>]*>.*?<\/iframe>/gi, '') // Remove iframes
    .replace(/javascript:/gi, '') // Remove javascript: protocol
    .replace(/on\w+\s*=/gi, ''); // Remove event handlers like onclick=

  // Validate timestamps
  if (typeof item.BeginOffsetMillis !== 'number' || item.BeginOffsetMillis < 0) {
    throw new Error('Invalid BeginOffsetMillis');
  }
  if (typeof item.EndOffsetMillis !== 'number' || item.EndOffsetMillis < 0) {
    throw new Error('Invalid EndOffsetMillis');
  }
  if (item.EndOffsetMillis < item.BeginOffsetMillis) {
    throw new Error('EndOffsetMillis must be greater than BeginOffsetMillis');
  }
  // Reasonable limit: 4 hours = 14,400,000 milliseconds
  if (item.BeginOffsetMillis > 14400000 || item.EndOffsetMillis > 14400000) {
    throw new Error('Timestamp exceeds reasonable call duration');
  }

  // Validate Sentiment (optional field)
  const validSentiments = ['POSITIVE', 'NEGATIVE', 'NEUTRAL', 'MIXED'];
  const sanitizedSentiment = item.Sentiment ? 
    item.Sentiment.toUpperCase().slice(0, 10).replace(/[^A-Z]/g, '') : 'NEUTRAL';

  // Validate Id
  if (!item.Id || typeof item.Id !== 'string') {
    throw new Error('Invalid Id');
  }
  const sanitizedId = item.Id.slice(0, 100).replace(/[^a-zA-Z0-9_-]/g, '');

  return {
    ParticipantRole: sanitizedRole,
    Content: sanitizedContent,
    BeginOffsetMillis: Math.floor(item.BeginOffsetMillis),
    EndOffsetMillis: Math.floor(item.EndOffsetMillis),
    Sentiment: sanitizedSentiment,
    Id: sanitizedId
  };
}

function validateTranscribeOutput(data: any): TranscribeOutput {
  if (!data || typeof data !== 'object') {
    throw new Error('Invalid transcribe output structure');
  }

  // Validate Transcript array
  if (!Array.isArray(data.Transcript)) {
    throw new Error('Transcript must be an array');
  }
  if (data.Transcript.length === 0) {
    throw new Error('Transcript array is empty');
  }
  if (data.Transcript.length > 10000) {
    throw new Error('Transcript array too large - possible DoS attack');
  }

  // Validate each transcript item
  const validatedTranscript = data.Transcript.map((item: any, index: number) => {
    try {
      return validateTranscriptItem(item);
    } catch (error) {
      throw new Error(`Invalid transcript item at index ${index}: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  });

  // Validate ConversationCharacteristics
  if (!data.ConversationCharacteristics || typeof data.ConversationCharacteristics !== 'object') {
    throw new Error('Invalid ConversationCharacteristics structure');
  }

  // Validate ContactSummary
  const contactSummary = data.ConversationCharacteristics.ContactSummary;
  if (!contactSummary || typeof contactSummary !== 'object') {
    throw new Error('Invalid ContactSummary structure');
  }

  // Validate summary content
  const summaryContent = contactSummary.AutoGenerated?.OverallSummary?.Content;
  if (summaryContent && typeof summaryContent !== 'string') {
    throw new Error('Invalid summary content type');
  }
  
  // Sanitize summary content
  const sanitizedSummary = summaryContent ? 
    summaryContent
      .slice(0, 5000) // Limit summary length
      .replace(/<script[^>]*>.*?<\/script>/gi, '')
      .replace(/<iframe[^>]*>.*?<\/iframe>/gi, '')
      .replace(/javascript:/gi, '')
      .replace(/on\w+\s*=/gi, '') : '';

  return {
    Transcript: validatedTranscript,
    ConversationCharacteristics: {
      ContactSummary: {
        AutoGenerated: {
          OverallSummary: {
            Content: sanitizedSummary
          }
        }
      }
    }
  };
}

// Input from Step Functions
interface StepFunctionsEvent {
  bucket: string;
  key: string;
  fileName: string;
  fileNameWithoutExt: string;
  timestamp: number;
  jobName: string;
  transcriptKey: string;
  formattedKey?: string;
}

export const handler = async (event: StepFunctionsEvent): Promise<StepFunctionsEvent> => {
  console.log('Received event:', JSON.stringify(event, null, 2));
  
  const { bucket, transcriptKey, fileNameWithoutExt } = event;
  
  try {
    // Get the transcript file
    const getCommand = new GetObjectCommand({
      Bucket: bucket,
      Key: transcriptKey
    });
    
    const response = await s3Client.send(getCommand);
    const body = await response.Body?.transformToString();
    
    if (!body) {
      throw new Error(`Empty response body for ${transcriptKey}`);
    }
    
    // Parse the transcript JSON
    const rawData = JSON.parse(body);
    
    // Validate the transcript data before processing
    const transcribeOutput = validateTranscribeOutput(rawData);
    
    // Format the transcript
    const formattedOutput = formatTranscript(transcribeOutput);
    
    // Save the formatted transcript to the transcripts/formatted/ folder
    const formattedKey = `transcripts/formatted/formatted_${fileNameWithoutExt}.json`;
    
    const putCommand = new PutObjectCommand({
      Bucket: bucket,
      Key: formattedKey,
      Body: JSON.stringify(formattedOutput, null, 2),
      ContentType: 'application/json'
    });
    
    await s3Client.send(putCommand);
    console.log(`Successfully formatted transcript and saved to ${formattedKey}`);
    
    // Return the updated event with the formatted key
    return {
      ...event,
      formattedKey
    };
  } catch (error) {
    console.error(`Error processing transcript ${transcriptKey}:`, error);
    throw error;
  }
};

function formatTranscript(transcribeOutput: TranscribeOutput): any {
  // Extract the summary
  const summary = transcribeOutput.ConversationCharacteristics?.ContactSummary?.AutoGenerated?.OverallSummary?.Content || 'No summary available';
  
  // Extract and format the transcript with timestamps
  const transcript = transcribeOutput.Transcript.map(item => {
    // Convert milliseconds to MM:SS.mmm format
    const formatTimeWithMilliseconds = (milliseconds: number): string => {
      const totalSeconds = milliseconds / 1000;
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = Math.floor(totalSeconds % 60);
      const ms = Math.floor((totalSeconds - Math.floor(totalSeconds)) * 1000);
      
      return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
    };
    
    const beginTime = formatTimeWithMilliseconds(item.BeginOffsetMillis);
    const endTime = formatTimeWithMilliseconds(item.EndOffsetMillis);
    
    return {
      speaker: item.ParticipantRole,
      text: item.Content,
      beginTime: beginTime,
      endTime: endTime
    };
  });
  
  // Return the formatted output
  return {
    summary,
    transcript
  };
}
