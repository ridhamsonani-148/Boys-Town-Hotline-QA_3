import {
  S3Client,
  GetObjectCommand,
  PutObjectCommand,
} from "@aws-sdk/client-s3";

const s3Client = new S3Client({});
const { BUCKET_NAME } = process.env;

if (!BUCKET_NAME) {
  throw new Error("Required environment variable BUCKET_NAME must be set");
}

interface TranscriptItem {
  ParticipantRole: string;
  Content: string;
  BeginOffsetMillis: number;
  EndOffsetMillis: number;
  Sentiment: string;
  Id: string;
}

interface TranscriptSummary {
  AutoGenerated: {
    OverallSummary: {
      Content: string;
    };
  };
}

interface TranscribeOutput {
  Transcript: TranscriptItem[];
  ConversationCharacteristics: {
    ContactSummary: TranscriptSummary;
  };
}

// No validation needed - transcripts come from trusted AWS Transcribe service
// and are only stored in S3, not DynamoDB

// Input from Step Functions
interface StepFunctionsEvent {
  bucket: string;
  key: string;
  fileName: string;
  fileNameWithoutExt: string;
  timestamp: number;
  jobName: string;
  transcriptKey: string;
  formattedKey?: string;
}

export const handler = async (
  event: StepFunctionsEvent
): Promise<StepFunctionsEvent> => {
  console.log("Received event:", JSON.stringify(event, null, 2));

  const { bucket, transcriptKey, fileNameWithoutExt } = event;

  try {
    // Get the transcript file
    const getCommand = new GetObjectCommand({
      Bucket: bucket,
      Key: transcriptKey,
    });

    const response = await s3Client.send(getCommand);
    const body = await response.Body?.transformToString();

    if (!body) {
      throw new Error(`Empty response body for ${transcriptKey}`);
    }

    // Parse the transcript JSON
    const transcribeOutput: TranscribeOutput = JSON.parse(body);

    // Format the transcript (no validation needed - data from trusted AWS Transcribe)
    const formattedOutput = formatTranscript(transcribeOutput);

    // Save the formatted transcript to the transcripts/formatted/ folder
    const formattedKey = `transcripts/formatted/formatted_${fileNameWithoutExt}.json`;

    const putCommand = new PutObjectCommand({
      Bucket: bucket,
      Key: formattedKey,
      Body: JSON.stringify(formattedOutput, null, 2),
      ContentType: "application/json",
    });

    await s3Client.send(putCommand);
    console.log(
      `Successfully formatted transcript and saved to ${formattedKey}`
    );

    // Return the updated event with the formatted key
    return {
      ...event,
      formattedKey,
    };
  } catch (error) {
    console.error(`Error processing transcript ${transcriptKey}:`, error);
    throw error;
  }
};

function formatTranscript(transcribeOutput: TranscribeOutput): any {
  // Extract the summary
  const summary =
    transcribeOutput.ConversationCharacteristics?.ContactSummary?.AutoGenerated
      ?.OverallSummary?.Content || "No summary available";

  // Extract and format the transcript with timestamps
  const transcript = transcribeOutput.Transcript.map((item) => {
    // Convert milliseconds to MM:SS.mmm format
    const formatTimeWithMilliseconds = (milliseconds: number): string => {
      const totalSeconds = milliseconds / 1000;
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = Math.floor(totalSeconds % 60);
      const ms = Math.floor((totalSeconds - Math.floor(totalSeconds)) * 1000);

      return `${minutes.toString().padStart(2, "0")}:${seconds
        .toString()
        .padStart(2, "0")}.${ms.toString().padStart(3, "0")}`;
    };

    const beginTime = formatTimeWithMilliseconds(item.BeginOffsetMillis);
    const endTime = formatTimeWithMilliseconds(item.EndOffsetMillis);

    return {
      speaker: item.ParticipantRole,
      text: item.Content,
      beginTime: beginTime,
      endTime: endTime,
    };
  });

  // Return the formatted output
  return {
    summary,
    transcript,
  };
}
