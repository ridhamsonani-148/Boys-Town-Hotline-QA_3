import { 
  S3Client, 
  GetObjectCommand, 
  PutObjectCommand 
} from '@aws-sdk/client-s3';

const s3Client = new S3Client({});
const { BUCKET_NAME } = process.env;

if (!BUCKET_NAME) {
  throw new Error('Required environment variable BUCKET_NAME must be set');
}

interface TranscriptItem {
  ParticipantRole: string;
  Content: string;
  BeginOffsetMillis: number;
  EndOffsetMillis: number;
  Sentiment: string;
  Id: string;
}

interface TranscriptSummary {
  AutoGenerated: {
    OverallSummary: {
      Content: string;
    }
  }
}

interface TranscribeOutput {
  Transcript: TranscriptItem[];
  ConversationCharacteristics: {
    ContactSummary: TranscriptSummary;
  }
}

// Input from Step Functions
interface StepFunctionsEvent {
  bucket: string;
  key: string;
  fileName: string;
  fileNameWithoutExt: string;
  timestamp: number;
  jobName: string;
  transcriptKey: string;
  formattedKey?: string;
}

export const handler = async (event: StepFunctionsEvent): Promise<StepFunctionsEvent> => {
  console.log('Received event:', JSON.stringify(event, null, 2));
  
  const { bucket, transcriptKey, fileNameWithoutExt } = event;
  
  try {
    // Get the transcript file
    const getCommand = new GetObjectCommand({
      Bucket: bucket,
      Key: transcriptKey
    });
    
    const response = await s3Client.send(getCommand);
    const body = await response.Body?.transformToString();
    
    if (!body) {
      throw new Error(`Empty response body for ${transcriptKey}`);
    }
    
    // Parse the transcript JSON
    const transcribeOutput: TranscribeOutput = JSON.parse(body);
    
    // Format the transcript
    const formattedOutput = formatTranscript(transcribeOutput);
    
    // Save the formatted transcript to the transcripts/formatted/ folder
    const formattedKey = `transcripts/formatted/formatted_${fileNameWithoutExt}.json`;
    
    const putCommand = new PutObjectCommand({
      Bucket: bucket,
      Key: formattedKey,
      Body: JSON.stringify(formattedOutput, null, 2),
      ContentType: 'application/json'
    });
    
    await s3Client.send(putCommand);
    console.log(`Successfully formatted transcript and saved to ${formattedKey}`);
    
    // Return the updated event with the formatted key
    return {
      ...event,
      formattedKey
    };
  } catch (error) {
    console.error(`Error processing transcript ${transcriptKey}:`, error);
    throw error;
  }
};

function formatTranscript(transcribeOutput: TranscribeOutput): any {
  // Extract the summary
  const summary = transcribeOutput.ConversationCharacteristics?.ContactSummary?.AutoGenerated?.OverallSummary?.Content || 'No summary available';
  
  // Extract and format the transcript with timestamps
  const transcript = transcribeOutput.Transcript.map(item => {
    // Convert milliseconds to MM:SS.mmm format
    const formatTimeWithMilliseconds = (milliseconds: number): string => {
      const totalSeconds = milliseconds / 1000;
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = Math.floor(totalSeconds % 60);
      const ms = Math.floor((totalSeconds - Math.floor(totalSeconds)) * 1000);
      
      return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
    };
    
    const beginTime = formatTimeWithMilliseconds(item.BeginOffsetMillis);
    const endTime = formatTimeWithMilliseconds(item.EndOffsetMillis);
    
    return {
      speaker: item.ParticipantRole,
      text: item.Content,
      beginTime: beginTime,
      endTime: endTime
    };
  });
  
  // Return the formatted output
  return {
    summary,
    transcript
  };
}
